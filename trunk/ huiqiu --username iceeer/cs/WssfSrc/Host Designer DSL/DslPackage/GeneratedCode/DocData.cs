//===============================================================================
// Microsoft patterns & practices
// Web Service Software Factory
//===============================================================================
// Copyright ï¿½ Microsoft Corporation.  All rights reserved.
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY
// OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE.
//===============================================================================
// The example companies, organizations, products, domain names,
// e-mail addresses, logos, people, places, and events depicted
// herein are fictitious.  No association with any real company,
// organization, product, domain name, email address, logo, person,
// places, or events is intended or should be inferred.
//===============================================================================


//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslShell = global::Microsoft.VisualStudio.Modeling.Shell;
using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslValidation = global::Microsoft.VisualStudio.Modeling.Validation;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;
using VSShellInterop = global::Microsoft.VisualStudio.Shell.Interop;


namespace Microsoft.Practices.ServiceFactory.HostDesigner
{
	/// <summary>
	/// Double-derived class to allow easier code customization.
	/// </summary>
	internal partial class HostDesignerDocData : HostDesignerDocDataBase
	{
		/// <summary>
		/// Constructs a new HostDesignerDocData.
		/// </summary>
		public HostDesignerDocData(global::System.IServiceProvider serviceProvider, global::System.Guid editorFactoryId) 
			: base(serviceProvider, editorFactoryId)
		{
		}
	}

	/// <summary>
	/// Class which represents a HostDesigner document in memory.
	/// </summary>
	internal abstract class HostDesignerDocDataBase : DslShell::ModelingDocData
	{

		#region Constraint ValidationController
		/// <summary>
		/// The controller for all validation that goes on in the package.
		/// </summary>
		private DslShell::VsValidationController validationController;
		private DslShell::ErrorListObserver errorListObserver;
		#endregion
		/// <summary>
		/// Document lock holder registered for the subordinate .diagram file.
		/// </summary>
		private DslShell::SubordinateDocumentLockHolder diagramDocumentLockHolder;

		/// <summary>
		/// Constructs a new HostDesignerDocDataBase.
		/// </summary>
		protected HostDesignerDocDataBase(global::System.IServiceProvider serviceProvider, global::System.Guid editorFactoryId) : base(serviceProvider, editorFactoryId)
		{
		}

		/// <summary>
		/// Returns a list of file format specifiers for the Save dialog box.
		/// </summary>
		protected override string FormatList
		{
			get
			{
                return global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel.SingletonResourceManager.GetString("FormatList"); 
			}
		}


		/// <summary>
		/// The controller for all validation that goes on in the package.
		/// </summary>
		public DslShell::VsValidationController ValidationController
		{
			get
			{
				if (this.validationController == null)
				{
					this.validationController = this.CreateValidationController();
					this.errorListObserver = new DslShell::ErrorListObserver(this.ServiceProvider);

					// register the observer so we can show the error/warning/msg in the VS output window.
					this.validationController.AddObserver(this.errorListObserver);
				}
				return this.validationController;
			}
		}

		/// <summary>
		/// Factory method to create a VSValidationController.
		/// </summary>
		protected virtual DslShell::VsValidationController CreateValidationController()
		{
			return new DslShell::VsValidationController(this.ServiceProvider, typeof(HostDesignerExplorerToolWindow));
		}
		
		/// <summary>
		/// When the doc data is closed, make sure we reset the valiation messages 
		/// (if there's any) from the ErrorList window.
		/// </summary>
		/// <param name="disposing"></param>
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (this.validationController != null)
				{
					this.validationController.ClearMessages();
					// un-register our observer with the controller.
					this.validationController.RemoveObserver(this.errorListObserver);
					this.validationController = null;
					if ( this.errorListObserver != null )
					{
						this.errorListObserver.Dispose();
						this.errorListObserver = null;
					}
				}
				if (this.diagramDocumentLockHolder != null)
				{
					this.diagramDocumentLockHolder.Dispose();
					this.diagramDocumentLockHolder = null;
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		/// <summary>
		/// Returns a collection of domain models to load into the store.
		/// </summary>
		protected override global::System.Collections.Generic.IList<global::System.Type> GetDomainModels()
		{
			return new global::System.Type[]
			{
				typeof(DslDiagrams::CoreDesignSurfaceDomainModel),
				typeof(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel)
			};
		}

		/// <summary>
		/// Loads the given file.
		/// </summary>
		protected override void Load(string fileName, bool isReload)
		{
			DslModeling::SerializationResult serializationResult = new DslModeling::SerializationResult();
			global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel modelRoot = null;
			DslModeling::ISchemaResolver schemaResolver = new DslShell::ModelingSchemaResolver(this.ServiceProvider);
			
			modelRoot = global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerSerializationHelper.Instance.LoadModel(serializationResult, this.Store.DefaultPartition, fileName, schemaResolver, this.ValidationController);

			// Report serialization messages.
			this.SuspendErrorListRefresh();
			try
			{
				foreach (DslModeling::SerializationMessage serializationMessage in serializationResult)
				{
					this.AddErrorListItem(new DslShell::SerializationErrorListItem(this.ServiceProvider, serializationMessage));
				}
			}
			finally
			{
				this.ResumeErrorListRefresh();
			}

			if (serializationResult.Failed)
			{	
				// Load failed, can't open the file.
				throw new global::System.InvalidOperationException(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel.SingletonResourceManager.GetString("CannotOpenDocument"));
			}
			else
			{
				this.SetRootElement(modelRoot);
			}
		}


		/// <summary>
		/// Validate the model before the file is saved.
		/// </summary>
		protected override bool CanSave(bool allowUserInterface)
		{
			// If a silent check then use a temporary ValidationController that is not connected to the error list to avoid any unwanted UI updates
			DslShell::VsValidationController vc = allowUserInterface ? this.ValidationController : this.CreateValidationController();
			if (vc == null)
			{
				return true;
			}

			// We check Load category first, because any violation in this category will cause the saved file to be unloadable justifying a special 
			// error message. If the Load category passes, we then check the normal Save category, and give the normal warning message if necessary.
			bool unloadableError = !vc.Validate(this.Store, DslValidation::ValidationCategories.Load) && vc.ErrorMessages.Count != 0;
			
			// Prompt user for confirmation if there are validation errors and this is not a silent save
			if (allowUserInterface)
			{
				vc.Validate(this.Store, DslValidation::ValidationCategories.Save);

				if (vc.ErrorMessages.Count != 0)
				{
					string errorMsg = (unloadableError ? "UnloadableSaveValidationFailed" : "SaveValidationFailed");
					global::System.Windows.Forms.DialogResult result = DslShell::PackageUtility.ShowMessageBox(this.ServiceProvider, global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel.SingletonResourceManager.GetString(errorMsg), VSShellInterop::OLEMSGBUTTON.OLEMSGBUTTON_YESNO, VSShellInterop::OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_SECOND, VSShellInterop::OLEMSGICON.OLEMSGICON_WARNING);
					return (result == global::System.Windows.Forms.DialogResult.Yes);
				}
			}
			
			return !unloadableError;
		}

		/// <summary>
		/// Saves the given file.
		/// </summary>
		protected override void Save(string fileName)
		{
			DslModeling::SerializationResult serializationResult = new DslModeling::SerializationResult();
			global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel modelRoot = (global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerModel)this.RootElement;

			global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerSerializationHelper.Instance.SaveModel(serializationResult, modelRoot, fileName, this.Encoding, false);
			// Report serialization messages.
			this.SuspendErrorListRefresh();
			try
			{
				foreach (DslModeling::SerializationMessage serializationMessage in serializationResult)
				{
					this.AddErrorListItem(new DslShell::SerializationErrorListItem(this.ServiceProvider, serializationMessage));
				}
			}
			finally
			{
				this.ResumeErrorListRefresh();
			}

			if (serializationResult.Failed)
			{	// Save failed.
				throw new global::System.InvalidOperationException(global::Microsoft.Practices.ServiceFactory.HostDesigner.HostDesignerDomainModel.SingletonResourceManager.GetString("CannotSaveDocument"));
			}
		}
	}
}

